generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ServiceType {
  STORAGE
  MOVING
  SHREDDING
}

enum OrderStatus {
  DRAFT
  QUOTED
  PENDING_PAYMENT
  PAID
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELED
  REFUNDED
}

enum PaymentStatus {
  REQUIRES_PAYMENT_METHOD
  REQUIRES_CONFIRMATION
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
}

enum PaymentProvider {
  STRIPE
  CASH
  BANK_TRANSFER
  OTHER
}

enum AddressType {
  PICKUP
  DROPOFF
  BILLING
}

/**
 * Your canonical catalog IDs.
 * These match the TypeScript union types you provided.
 */
enum CatalogItemId {
  // STORAGE
  small_box
  medium_box
  large_box
  xl_box
  suitcase
  half_container
  full_container

  // MOVING
  small_move
  one_bedroom_flat
  two_bedroom_flat
  three_bedroom_flat
  four_bedroom_flat
  office_move

  // SHREDDING
  bag
  archive_box
}

enum MovingPackageId {
  basic_package
  move_and_pack
}

model Customer {
  id        String   @id @default(cuid())
  email     String?  @unique
  phone     String?
  fullName  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
}

model AdminUser {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String
  passwordHash String?
  role         String   @default("admin")
  isActive     Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * Catalog of items for all services, using stable ids and skus.
 * - id: enum (safe, no typos)
 * - sku: string (matches your TS IDs exactly, e.g. "small-box")
 */
model ServiceItem {
  id          CatalogItemId @id
  serviceType ServiceType
  sku         String        @unique
  name        String
  description String?
  isActive    Boolean       @default(true)

  prices      ServiceItemPrice[]
  orderItems  OrderItem[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([serviceType])
  @@index([isActive])
}

model ServiceItemPrice {
  id             String      @id @default(cuid())
  serviceItemId  CatalogItemId
  serviceItem    ServiceItem @relation(fields: [serviceItemId], references: [id], onDelete: Cascade)

  currency       String      @default("GBP")
  unitPriceMinor Int

  // Optional price window
  effectiveFrom  DateTime?
  effectiveTo    DateTime?
  isActive       Boolean     @default(true)

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([serviceItemId, currency])
  @@index([currency])
  @@index([isActive])
}

/**
 * Moving Packages
 */
model MovingPackage {
  id          MovingPackageId @id
  sku         String          @unique // e.g. "basic-package"
  name        String
  description String?
  isActive    Boolean         @default(true)

  prices      MovingPackagePrice[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isActive])
}

model MovingPackagePrice {
  id              String        @id @default(cuid())
  packageId       MovingPackageId
  movingPackage   MovingPackage @relation(fields: [packageId], references: [id], onDelete: Cascade)

  currency        String @default("GBP")
  priceMinor      Int

  effectiveFrom   DateTime?
  effectiveTo     DateTime?
  isActive        Boolean @default(true)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([packageId, currency])
  @@index([currency])
  @@index([isActive])
}

model Order {
  id          String      @id @default(cuid())
  orderNumber String      @unique
  serviceType ServiceType
  status      OrderStatus @default(DRAFT)

  customerId  String
  customer    Customer    @relation(fields: [customerId], references: [id], onDelete: Restrict)

  // Booking / schedule
  serviceDate DateTime?
  timeSlotId  String?
  timeSlot    TimeSlot?   @relation(fields: [timeSlotId], references: [id], onDelete: SetNull)

  // Options / add-ons
  packingAssistance Boolean @default(false)
  notes             String?

  // Money fields (store in minor units e.g. pence)
  currency      String @default("GBP")
  subtotalMinor Int    @default(0)
  discountMinor Int    @default(0)
  taxMinor      Int    @default(0)
  totalMinor    Int    @default(0)

  externalRef String?
  metadata    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items     OrderItem[]
  addresses Address[]
  payments  Payment[]

  @@index([customerId])
  @@index([status])
  @@index([serviceType])
  @@index([serviceDate])
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Optional link to catalog item
  serviceItemId CatalogItemId?
  serviceItem   ServiceItem? @relation(fields: [serviceItemId], references: [id], onDelete: SetNull)

  sku      String?
  name     String
  quantity Int @default(1)

  unitPriceMinor Int @default(0)
  lineTotalMinor Int @default(0)

  months  Int?
  details Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([serviceItemId])
}

model Address {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  type       AddressType
  label      String?
  line1      String
  line2      String?
  city       String
  region     String?
  postalCode String
  country    String @default("GB")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
}

model Payment {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  provider PaymentProvider @default(STRIPE)
  status   PaymentStatus   @default(REQUIRES_PAYMENT_METHOD)

  currency    String @default("GBP")
  amountMinor Int

  providerRef String?
  receiptUrl  String?
  raw         Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([status])
  @@index([provider])
}

model TimeSlot {
  id        String  @id @default(cuid())
  name      String
  startTime String?
  endTime   String?
  isActive  Boolean @default(true)

  orders Order[]

  @@unique([name])
}

model Setting {
  key       String @id
  value     Json
  updatedAt DateTime @updatedAt
}
